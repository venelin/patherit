---
pdf_document:
  toc: yes
author: "Venelin Mitov"
output:
  html_document: null
  pdf_document: default
  toc: yes
title: "A Tutorial for the patherit package"
keep_tex: yes
---
  
```{r setup, include=F}
library(knitr)
library(rmarkdown)
#opts_chunk$set(size='tiny', out.extra='style="display:block; margin: auto;"', fig.align="center")

#library(rmarkdown)
# render('patherit-intro.Rmd', output_format='pdf_document', clean=TRUE)
opts_chunk$set(dev='pdf',
               dev.args=list(colormodel='cmyk', family='Helvetica', pointsize=10),
               dpi=150)
```

# Introduction
The **patherit** package provides an implementation of the Pylogenetic Mixed Model assuming an Ornstein-Uhlenbeck (OU)  or a Brownian Motion (BM) process of trait evolution along the branches. The package comes with an efficient likelihood calculation that scales to large phylogenies (currently tested with up to 100000 tips) and, if needed, can perform the likelihood calculation using the package **Rmpfr** for high precision floating point operations. 
Currently, the package depends on the packages **ape**, **data.table**, **coda**, **adaptMCMC** and 
**boot**. The most important functions of the package are "lik.poumm" (see ?lik.poimm), which performs likelihood calculation, "ml.poumm" (type ?ml.poumm), which fits POUMM to a tree and data at the tips using maximum likelihood and mcmc.poumm, which runs an MCMC fit to a tree and data. The algorithm for likelihood calculation has been extensively tested and applied on various real as well as synthetic data.

Note: The high-precision likelihood calculation is usually needed in case of accumulating numerical errors due to extreme values of some of the parameters alpha, theta, sigma or sigmae or extreme (i.e. very long or very short) branch lengths in the phylogeny. As the Rmpfr package is currently not supported on all linux platforms, the poumm package doesn't explicitly depend on it, but you will need to install it manually and import it in case you specify usempfr=2 in the call to lik.poumm, ml.poumm or mcmc.poumm. 


# Installing the package
```{r install, eval=F}
#install.packages('patherit_0.3.tgz', type='binary', repos=NULL)
```

# An example with artificial phylogenetic and phenotypic data

We begin by generating a phylogeny and phenotypic values at its tips.
```{r example, cache=TRUE}
library(patherit)

set.seed(1)
# Number of tips
N <- 2000
# true parameters
alpha <- 12
theta <- 4
sigma <- 4
sigmae <- 1

tree <- rtree(N)
tree$edge.length <- tree$edge.length/40

g <- generateTraitOU(tree, g0=5, alpha=alpha, theta=theta, sigma=sigma)
z <- rnorm(N, mean=0, sd=sigmae)+g[1:N]

sigma^2/(2*alpha)/(sigma^2/(2*alpha)+sigmae^2)
var(g)/var(z)

tMax <- max(nodeTimes(tree, tipsOnly=TRUE))
tMean <- mean(nodeTimes(tree, tipsOnly=TRUE))
H2.poumm(alpha, sigma, sigmae, tMax)
H2.poumm(alpha, sigma, sigmae, tMean)

```

# Plot the phenotype along the tree
```{r plottreedata, fig.width=4, fig.height=3}
boxplotTraitAlongTree(z, tree, boxwex=0.02, nGroups=10, xlim=c(0, .5))
```

# Running a POUMM analysis
## One likelihood calculation

```{r lik.poumm}
# you need to do this only for performance speed-up and if you have
# multiple explicit calls to lik.poumm
pruneInfo <- pruneTree(tree)
#likelihood at the true value
lik <- lik.poumm(z, tree, alpha, theta, sigma, sigmae, log=T, distgr='maxlik', pruneInfo=pruneInfo)
```

```{r fit-uk}
load('../../spvl/DATA/Real/Hodcroft_2014/ukdata.RData')
ukdata
treeUK <- ukdata$tree[[8]]
zUK <- ukdata$v[[8]]

fitUK <- POUMM(z=zUK, tree=treeUK, distgr='maxlik', usempfr=0, doML=TRUE, doMCMC=TRUE, n.chains=3, n.mcmc=1e6, n.adapt=1e5, verbose=TRUE)

summary.fitUK <- summary(fitUK, thin=1000, mode='short')

system.time(anPPUK <- PP(z=zUK, tree=treeUK, bootstraps=1000))
```
## Performing an ML and a MCMC fit 
```{r fit, echo=TRUE, cache=TRUE}
library(doParallel)
cl <- makeCluster(4)
registerDoParallel(cl)

fitML <- POUMM(z=z, tree=tree, distgr=mean(z), usempfr=1, doML=TRUE, 
               parFixed=c(sigmae=0), 
               doMCMC=FALSE, n.chains=3, n.mcmc=6e5, n.adapt=1e5, verbose=TRUE)

for(th in -20:20)
  print(-lik.poumm(z, tree, fitML$ML$par[1], th,  #fitML$ML$par[2], 
                  fitML$ML$par[3], fitML$ML$par[4], distgr='maxlik', usempfr=1))

summary(fitML, mode='short')

# test with the Rphylopars package
library(Rphylopars)
fit.phylopars <- phylopars(data.table(species=tree$tip.label, z=z), tree, model='OU', pheno_error=FALSE, REML=FALSE)



fit <- POUMM(z=z, tree=tree, distgr='maxlik', usempfr=0, doML=TRUE, doMCMC=TRUE, n.chains=3, n.mcmc=6e5, n.adapt=1e5, verbose=TRUE)


summary.fit <- summary(fit, thin=100, mode='short')

system.time(anPP <- PP(z=z, tree=tree, bootstraps=1000))

df <- summary.fit[stat%in%c('sigmae', 'sigmaGtMean'), data.table(sigmae=unclass(mcmc[[1]][,1]), sigmaGtMean=unclass(mcmc[[2]][,1]))]

commonTheme = list(labs(color="Density",fill="Density",
                        x=expression(sigmae),
                        y=expression(sigmaGtMean)),
                   theme_bw(),
                   theme(legend.position=c(0,1),
                         legend.justification=c(0,1)))

ggplot(data=df,aes(sigmae,sigmaGtMean)) + 
  stat_density2d(aes(fill=..level..,alpha=..level..),geom='polygon',colour='black') + 
  scale_fill_continuous(low="green",high="red") +
  geom_smooth(method=lm,linetype=2,colour="red",se=F) + 
  guides(alpha="none") + commonTheme



  geom_point() + commonTheme

dt <- summary.fit$MCMC





dcast(dt, stat~chain, 
      fun=list(function(ESS) sum(unlist(ESS)), 
               function(lModes) {if(length(lModes)>=1) lModes[[which.max(sapply(lModes, function(m) attr(m, 'logpost')))]] else NULL}, 
               function(lHPDs) if(length(lHPDs)>=1) colMeans(do.call(rbind, lHPDs)) else NULL, 
               function(lHPDs) if(length(lHPDs)>=1) colMeans(do.call(rbind, lHPDs)) else NULL,
               function(mcs) if(length(mcs)>=1) mcmc(do.call(rbind, mcs), thin=thin(mcs)) else NULL),
      value.var=list('ESS', 'Mode', 'HPD', 'HPD50', 'mcs'))

print(summary.fit$ML)
print(summary.fit$MCMC)

merge(summary.fit$ML, dcast(summary.fit$MCMC, stat~chain, sep='.MCMC_', subset=.(chain!=1), value.var=c('ESS', 'Mode', 'HPD', 'HPD50', 'mcs', 'samplePrior')), by='stat', all=TRUE)

fit.PMM <- PMM(z=z, tree=tree, distgr='maxlik', usempfr=0, doML=TRUE, doMCMC=TRUE, n.mcmc=2e5, n.chains=3, verbose=TRUE)

summary.fit.PMM <- summary(fit.PMM, start=5e4)

print(summary.fit.PMM$ML)
print(summary.fit.PMM$MCMC)

dt <- summary(fit.PMM, start=5e4, merge.ML.MCMC=FALSE, dcast.MCMC=FALSE)$MCMC
dt[, Mode[[2]]]
dcast(dt, stat~samplePrior, 
      fun=list(sum, function(lModes) lModes[[which.max(sapply(lModes, function(m) attr(m, 'logpost')))]], 
               function(lHPDs) colMeans(do.call(rbind, lHPDs)), 
               function(lHPDs) colMeans(do.call(rbind, lHPDs)),
               function(mcs) mcmc(do.call(rbind, mcs), thin=thin(mcs))),
      value.var=list('ESS', 'Mode', 'HPD', 'HPD50', 'mcs'))
```

## Performing an ML-fit
```{r ml-fit, echo=TRUE, cache=TRUE}
# maximum likelihood fit
mlfit <- ml.poumm(z=z, tree=tree, distgr='maxlik', parMax=c(alpha=10, theta=10, sigma=10, sigmae=10))

print(mlfit$par)

# ml likelihood value versus value at the original true params
print(c(-mlfit$value, lik))
```

## Performing an MCMC fit
```{r mcmc-fit, echo=TRUE, results='hide', cache=TRUE}
mcmcfit <- mcmc.poumm(z, tree, n.mcmc=2e5, n.adapt=20000, thin=100, acc.rate=0.1, divideEdgesBy=100,
                      scale=matrix(c(400,   0.00,  0.00,  0.00,
                                     0.00,  2.00,  0.00,  0.00,
                                     0.00,  0.00,  0.02,  0.00,
                                     0.00,  0.00,  0.00,  0.02), nrow=4, ncol=4, byrow=T),
                      distgr="maxlik")

```

```{r mcmc-analysis}
# this produces a worning which should be harmless
mcmcAnalysis <- analyseMCMCs(chains=mcmcfit$chains,
                             stat=function(par) {
                               H2e.poumm(z=z, sigmae=sqrt(par[4]))
                             }, 
                             statName='H2.OUe', 
                             start=1e5, end=2e5, thin=100)
```

## Comparing point estimates
```{r compare-results}
# point-estimates of broad-sense heritability. 
# A difference between H2eq and H2e, i.e. H2eq>H2e shows that the process has'nt still
# converged to the stationary OU distribution.
print(c(
  H2eq.true=H2.poumm(alpha, sigma, sigmae, t=Inf, tm=0),
  H2eq.ml.poumm=H2.poumm(mlfit$par[1], mlfit$par[3], mlfit$par[4], t=Inf, tm=0),
  H2e.ml.poumm=H2e.poumm(z=z, sigmae=mlfit$par[4]),
  H2e.mcmc.poumm=mcmcAnalysis$Mode))

# 95% CI from the MCMC
print(mcmcAnalysis$HPD)
```

# Running an ANOVA-CPP analysis
```{r anova-cpp, cache=TRUE}
cpps <- analyseCPPs(z, tree, CPPthr=0.05)
cpps$analysis.CPP[c('rA', 'bCI95lower', 'bCI95upper')]
```

# Empirical heritability from known genotypic and environmental contributions
```{r empirical}
var(g)/var(z)
```

# Further information and help
For further information, look in the package help-pages. If you cannot find the answer, please write to venelin.mitov@bsse.ethz.ch. 
